/**
 * Z64Text.java
 * Class representing Zelda 64 text files
 */

import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;

/**
 * PAL Debug ROM text table locations
 * <p>
 * base = [code + 0x12E4C0]
 * <p>
 * nes at   [base + 0x0]
 * ger at   [base + 0x4228]
 * fra at   [base + 0x6338]
 * staff at [base + 0x8448]
 * <p>
 * end = [base + 0x85D0]
 */

public class Z64Text implements Iterable<RomFile> {
    private final ArrayList<RomFile> _textRomFiles;

    /**
     * Constructor for the Z64Text class.
     *
     * @param textFiles List of text files to process.
     * @param code      Z64Code object for managing code arrays.
     */
    public Z64Text(ArrayList<File> textFiles, Z64Code code) {
        _textRomFiles = new ArrayList<>();

        // Text tables
        for (String tableName : Globals.TEXT_TABLE_NAMES) {
            for (File f : textFiles) {
                if (f.getName().equals(tableName)) {
                    byte[] tableData = Globals.fileToByteArr(f);

                    // Attempt to fix Ocarina Text Editor tables (only affects the NES table)
                    if (tableName.equals(Globals.CODE_TABLE_TEXT_NES_NAME)) {
                        patchMessageTable(tableData);
                    }

                    // Append table to code
                    code.addArray(tableData, tableName);
                }
            }
        }

        // Text binaries
        for (String binName : Globals.TEXT_BIN_NAMES) {
            for (File f : textFiles) {
                if (f.getName().equals(binName)) {
                    _textRomFiles.add(new RomFile(f));
                }
            }
        }
    }

    /**
     * Fixes message tables that were generated by Ocarina Text Editor.
     *
     * @param table Byte array representing the message table to patch.
     */
    private void patchMessageTable(byte[] table) {
        // Check if the first message in the table is 0xFFFC
        // Ocarina Text Editor produces tables that work this way, but ZAPDTR will not work with it
        if (!(((((int) table[0]) & 0xFF) == 0xFF) && ((((int) table[1]) & 0xFF) == 0xFC))) {
            return;
        }

        System.out.println("    Patching message table...");

        // Make a copy of the table entry for 0xFFFC
        byte[] msgEntryFFFC = new byte[8];
        System.arraycopy(table, 0, msgEntryFFFC, 0, msgEntryFFFC.length);

        // Shift all entries back by one
        for (int i = 8; i < table.length; i++) {
            table[i - 8] = table[i];
        }

        // Make a copy of the table entry for 0xFFFD
        byte[] msgEntryFFFD = new byte[8];
        for (int i = 0; i < table.length - 1; i++) {
            if (((((int) table[i]) & 0xFF) == 0xFF) && (((int) table[i + 1]) & 0xFF) == 0xFD) {
                System.arraycopy(table, i, msgEntryFFFD, 0, msgEntryFFFD.length);
                break;
            }
        }

        // Write message FFFC to the correct location
        System.arraycopy(msgEntryFFFC, 0, table, table.length - 24, msgEntryFFFC.length);
        // Write message FFFD to the correct location
        System.arraycopy(msgEntryFFFD, 0, table, table.length - 16, msgEntryFFFD.length);
        // Write message FFFF
        final byte[] msgEntryFFFF = {-1, -1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
        System.arraycopy(msgEntryFFFF, 0, table, table.length - 8, msgEntryFFFF.length);
    }

    /**
     * Provides an iterator for the ROM files.
     *
     * @return An iterator over the `RomFile` objects in this class.
     */
    @Override
    public Iterator<RomFile> iterator() {
        return _textRomFiles.iterator();
    }
}
